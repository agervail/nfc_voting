<html><head></head><body class="c15">
### Dependencies

For the galileo you need to use a linux distibution.
* Python
* Python-nfcpy
* Mosquitto

On the server side you will need.
* Python
* Python-nfcpy
* Python-pygame
* Mosquitto
* NodeJS
* MongoDB


### Usage
First you must launch the three readers on the galileo, one for each nfc reader with a different vote value.
```
python read.py 002:004 0
```

On the server side you have to run the mongoDB database and the mqtt broker.
```
sudo ./bin/mongod --rest
mosquitto

```
Then you run the NodeJS server and the display python programm.
```
node serv.js
python affichage.py
```

### Introduction
<p class="c2"><span>Le capteur que l&rsquo;on nous a confi&eacute; est un lecteur de Tag NFC. Le but de ce projet &eacute;tait de r&eacute;cup&eacute;rer les donn&eacute;es de ce lecteur et de s&rsquo;en servir pour effectuer un vote. L&rsquo;id&eacute;e &eacute;tait de relier trois lecteurs NFC sur un galileo et d&rsquo;affecter &agrave; chacun une valeur pour le vote actuel (Positif, N&eacute;gatif, Neutre). Ce syst&egrave;me de vote permet une grande facilit&eacute; d&rsquo;utilisation puisqu&rsquo;on peut imaginer l&rsquo;utiliser dans une conf&eacute;rence ou chaque invit&eacute; a un badge avec un Tag NFC dont il se servira pour voter simplement en l&rsquo;approchant du lecteur correspondant &agrave; son choix. Ce syst&egrave;me rend le vote tr&egrave;s rapide et permet du surcro&icirc;t de v&eacute;rifier que chaque personne ne vote qu&rsquo;une fois.</span></p><p class="c2"><span>Les diff&eacute;rents outils utilis&eacute;s sont Mqtt et MongoDB. Nous les utilisons au travers de scripts NodeJS et Python.</span></p><p class="c0"><span></span></p>

### Architecture

Voici l&rsquo;architecture du projet :<p class="c0"><span></span></p><p class="c2 c18"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 470.50px; height: 348.27px;"><img alt="" src="images/image00.png" style="width: 470.50px; height: 348.27px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span></span></p><p class="c2"><span>Les trois lecteurs NFC sons connect&eacute;s en USB sur le port </span><span class="c6">USB Host </span><span>du Galileo. Le Galileo est reli&eacute; directement au PC par un cable RJ 45.</span></p>

### Galileo
<p class="c2"><span>Le Galileo fait tourner un syst&egrave;me Linux pr&eacute;sent sur sa carte SD. Le fait d&rsquo;avoir Linux sur le </span><span>Galileo nous permet d&rsquo;avoir le support de l&rsquo;USB ainsi qu&rsquo;un interpr&egrave;te python et l&rsquo;ajout des librairies n&eacute;cessaires pour mqtt est &eacute;galement facilit&eacute;. Nous avons compil&eacute; mosquitto (Mqtt) directement sur la carte pour pouvoir lancer un broker Mqtt et se servir des bindings python pour le Mqtt.</span></p><h2 class="c2"><a name="h.1osdm9s5zv2k"></a><span>PC</span></h2><p class="c2"><span>Le PC a lui aussi un broker Mqtt qui tourne et qui lui permet de recevoir les messages envoy&eacute; par le Galileo. On lance &eacute;galement une base de donn&eacute;es MongoDB qui nous sert &agrave; stocker les votes. Pour finir nous utilisons un serveur NodeJS pour recevoir les messages du Galileo et remplir la base de donn&eacute;es.</span></p><p class="c0"><span></span></p><h1 class="c2"><a name="h.i0rfymv6vvl4"></a><span>Logiciel</span></h1><h2 class="c2"><a name="h.155ox57qjy2b"></a><span>Galileo</span></h2><p class="c2"><span>On lance trois scripts python, un pour chaque lecteur NFC branch&eacute; en USB. Chacun g&egrave;re une valeur pour le vote (Positif=0, N&eacute;gatif=1, Neutre=2). Pour lancer ces scripts il faut r&eacute;cup&eacute;rer l&rsquo;identifiant du device USB &agrave; l&rsquo;aide de la commande lsusb :</span></p><p class="c0"><span></span></p><a href="#" name="ecfa5ede0d0f01a851eea03ae6dcc29fdd6bcb6d"></a><a href="#" name="3"></a><table cellpadding="0" cellspacing="0" class="c11"><tbody><tr class="c5"><td class="c14"><p class="c2 c3"><span class="c9 c1 c16">root@clanton:~# lsusb</span></p><p class="c3 c2"><span class="c1">Bus </span><span class="c1">002</span><span class="c1">&nbsp;Device </span><span class="c1">003</span><span class="c9 c1 c16">: ID 05e3:0608 Genesys Logic, Inc. USB-2.0 4-Port HUB</span></p><p class="c3 c2"><span class="c9 c1 c16">Bus 001 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub</span></p><p class="c3 c2"><span class="c9 c1 c16">Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span></p><p class="c3 c2"><span class="c1">Bus </span><span class="c1 c4">002</span><span class="c1">&nbsp;Device </span><span class="c1 c4">005</span><span class="c1">: ID 04e6:5591</span><span class="c1 c4 c9">&nbsp;SCM Microsystems, Inc.</span></p><p class="c3 c2"><span class="c9 c1 c16">Bus 002 Device 004: ID 04e6:5591 SCM Microsystems, Inc.</span></p></td></tr></tbody></table><p class="c0"><span></span></p><p class="c2"><span>Par exemple si l&rsquo;on s&rsquo;int&eacute;resse au premier lecteur SCM Microsystems, les identifiants qui nous int&eacute;ressent sont 002 et 005.</span></p><p class="c2"><span>Admettons qu&rsquo;on affecte &agrave; ce lecteur la valeur 0, voici l&rsquo;appel &agrave; effectuer :</span></p><p class="c0"><span></span></p><a href="#" name="6e5d20302cfb2e6bcd6cf63a9574416d0c10282b"></a><a href="#" name="4"></a><table cellpadding="0" cellspacing="0" class="c11"><tbody><tr class="c5"><td class="c14"><p class="c3 c2"><span class="c1">python read.py 002:005 1</span></p></td></tr></tbody></table><p class="c0"><span></span></p><p class="c2"><span>On fera de m&ecirc;me pour les autres lecteurs.</span></p><p class="c2"><span>Le script read.py se sert de la librairie python nfc. On d&eacute;finit un handler pour chaque lecture d&rsquo;un tag NFC. Ce handler lit le contenu du tag NFC et transmet dans un message Mqtt l&rsquo;id du votant et la valeur du vote.</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><span></span></p><h2 class="c2"><a name="h.j8ot1tihnb6"></a><span>PC</span></h2><p class="c2"><span>Du c&ocirc;t&eacute; du PC on a dans un premier temps un serveur NodeJS qui permet d&rsquo;interfacer avec le Galileo, la base de donn&eacute;es MongoDB et le programme python d&rsquo;affichage des votes.</span></p><p class="c2"><span>La base de donn&eacute;es MongoDB permet le stockage des votes. Elle nous permet &eacute;galement indirectement de v&eacute;rifier qu&rsquo;une personne ne v&ocirc;te pas deux fois gr&acirc;ce &agrave; l&rsquo;exception duplicate key qui est lev&eacute; si la personne a d&eacute;j&agrave; v&ocirc;t&eacute;.</span></p><p class="c0"><span></span></p><p class="c2"><span>Pour le serveur NodeJS on a besoin de deux parties principales.</span></p><p class="c2"><span>La premi&egrave;re partie est la base de donn&eacute;es mongoDB. On se connecte &agrave; celle-ci pour pouvoir ajouter des entr&eacute;es. Pour ajouter des entr&eacute;es il faut cr&eacute;er un sch&eacute;ma, il est compos&eacute; d&#39;un id unique et de la valeur du vote.</span></p><p class="c2"><span>La seconde partie est le support des messages mqtt. A chaque vote, on re&ccedil;oit un message mqtt qui nous en informe. Pour cela on souscrit au topic des votes, avec un client qui &eacute;coute sur l&#39;ip du galileo.</span></p><p class="c2"><span>A chaque r&eacute;ception d&#39;un message on tente d&#39;ins&eacute;rer le vote avec l&#39;id du votant. Si cet id est d&eacute;j&agrave; pr&eacute;sent dans la table on ne duplique pas son vote et on affiche un message d&#39;erreur. Si le vote est valide on transmet un second message mqtt sur un autre topic qui servira &agrave; l&#39;affichage.</span></p><p class="c0"><span class="c6"></span></p><p class="c2"><span>Le programme d&rsquo;affichage lorsqu&rsquo;il est lanc&eacute; r&eacute;cup&egrave;re les valeurs d&eacute;j&agrave; pr&eacute;sente en base de donn&eacute;es. Par la suite &agrave; chaque r&eacute;ception d&rsquo;un message mqtt constitu&eacute; de la valeur du vote l&rsquo;affichage est actualis&eacute;. L&rsquo;affichage est r&eacute;alis&eacute; &agrave; l&rsquo;aide de la librairie pygame qui permet d&rsquo;afficher des rectangles et du texte. Les coordonn&eacute;es des rectangles sont calcul&eacute;s selon la taille du plus grand des trois, de mani&egrave;re &agrave; ce que l&rsquo;&eacute;chelle soit respect&eacute;e.</span></p><p class="c2 c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="affichage.png" src="images/image01.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>
